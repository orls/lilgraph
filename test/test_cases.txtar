Parser test cases for lilgraph format. 

Note that adding test-cases data files in here does *not* mean they automatically get tested: you
need to update the relevant test function's table of inputs and/or expectations.
See lilgraph_test.go.

-- happy/simple-nodes.lilgraph --
AAA
BBB CCC
DDD; EEE;
-- happy/simple-nodes.whitespace-and-comments.lilgraph --

    AAA      // this is a C-style-comment
	BBB // this node should have a tab before it
CCC

/* this is a block comment, containing an otherwise-valid node:
XXX
        /* block comment inside a block comment */   
        // c-style comment inside a block comment
        # hash-comment inside a block comment
   */
#XXX
# XXX

DDD EEE

// want some // comments in yr comments?
//want some// comments in yr comments?
#want some#comments in yr comments?
// # want some comments in yr comments?
# // want some comments in yr comments?
//# want some comments in yr comments?
#// want some comments in yr comments?

-- happy/simple-nodes.expected.json --
{"ast_items": [
    {"ast_type": "node_def", "id":"AAA"},
    {"ast_type": "node_def", "id":"BBB"},
    {"ast_type": "node_def", "id":"CCC"},
    {"ast_type": "node_def", "id":"DDD"},
    {"ast_type": "node_def", "id":"EEE"}
]}
-- happy/simple-edges.lilgraph --
A->B -> C
C ----> A
D------->E
-- happy/simple-edges.expected.json --
{"ast_items": [
    {"ast_type": "edge_chain", "from": "A", "steps": [{"to": "B"}, {"to":"C"}]},
    {"ast_type": "edge_chain", "from": "C", "steps": [{"to": "A"}]},
    {"ast_type": "edge_chain", "from": "D", "steps": [{"to": "E"}]}
]}
-- dubious/simple-edges-multiline.lilgraph --
// TODO: these are technically valid because it's easiest to write the grammar
// this way...but I'm on the fence about it.
A
->B

->
C

C ->
A

D
---->
E


-- happy/edge-attrs.lilgraph --
// Empty attrs ignored
A -[]-> B
B -[/* ... */]-> C

// Only regular attrs; various seps.
// TODO: quoted strings, plain numbers etc. Grammar is too limited right now
C -[foo=fooval bar=barval, ]-> D
D-----[baz=bazval,quux=quuxval]--->E
E-[
    foo=fooval,
    bar=barval,
]->F

// Only the special type pseudo-attr
F -[myedgetype]-> G
G -[myedgetype;]-> H

// Both type and regular attrs.

H -[myedgetype; foo=fooval bar=barval, ]-> I
I-----[myedgetype baz=bazval,quux=quuxval]--->J
J-[
    myedgetype  /*..*/
    foo=fooval,
    bar=barval,
]->K



-- happy/edge-attrs.expected.json --
{"ast_items": [
    {"ast_type": "edge_chain", "from": "A", "steps": [{"to": "B"}]},
    {"ast_type": "edge_chain", "from": "B", "steps": [{"to": "C"}]},
    {"ast_type": "edge_chain", "from": "C", "steps": [{"to": "D",
        "attrs": {
            "foo": "fooval",
            "bar": "barval"
        }
        }]},
    {"ast_type": "edge_chain", "from": "D", "steps": [{"to": "E",
        "attrs": {
            "baz": "bazval",
            "quux": "quuxval"
        }
    }]},
    {"ast_type": "edge_chain", "from": "E", "steps": [{"to": "F",
        "attrs": {
            "foo": "fooval",
            "bar": "barval"
        }
    }]},
    {"ast_type": "edge_chain", "from": "F", "steps": [{"to": "G", "type": "myedgetype"}]},
    {"ast_type": "edge_chain", "from": "G", "steps": [{"to": "H", "type": "myedgetype"}]},
    {"ast_type": "edge_chain", "from": "H", "steps": [{"to": "I", "type": "myedgetype",
        "attrs": {
            "foo": "fooval",
            "bar": "barval"
        }
    }]},
    {"ast_type": "edge_chain", "from": "I", "steps": [{"to": "J", "type": "myedgetype",
        "attrs": {
            "baz": "bazval",
            "quux": "quuxval"
        }
    }]},
    {"ast_type": "edge_chain", "from": "J", "steps": [{"to": "K", "type": "myedgetype",
        "attrs": {
            "foo": "fooval",
            "bar": "barval"
        }
    }]}
]}

-- bad/cyclic-1.lilgraph --
// no apex node
a -> b -> c -> a

-- bad/cyclic-2.lilgraph --
// Same as cyclic-1.lilgraph, just mixed-up & non-chained form.
c -> a
a -> b
b -> c

-- bad/cyclic-3.lilgraph --
// Has a valid apex node, but then has a later cycle .
a -> b -> c -> b

-- bad/cyclic-4.lilgraph --
// Has several valid apex nodes, but has an eventual cycle in the middle
a -> b           // apex, no cycle
c -> d           // apex, no cycle
e -> f -> g -> h // apex, no cycle yet...
h -> f           // ... cycle!
h -> i -> j      // non-apex, continues a path from above
k -> l           // apex, no cycle

-- happy/node-ordering.lilgraph --
// Nodes are returned in rank order; within a rank, nodes stay in the order of their ID first
// textual appearance.

c1

a -> b1 -> c2

b2
b3

b3 -> c3
a -> b3
a -> b2

-- happy/node-ordering.expected-order.json --
[
    "c1", // rank 0
    "a",  // rank 0
    "b2", // rank 0
    "b1", // rank 1
    "b3", // rank 1
    "c2", // rank 2
    "c3", // rank 2
]

-- happy/multirank.lilgraph --
// x and e end up getting pushed several ranks back from their first appearances
a -> x
a -> b -> c -> d
a -> e
b -> x
c -> x
d -> x -> e

-- happy/multirank.expected-order.json --
[
    "a",
    "b",
    "c",
    "d",
    "x",
    "e"
]